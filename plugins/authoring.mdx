---
title: "Authoring a Plugin"
description: "How to write a new plugin"
---

Processors implement the `processor` **interface** defined in `.tangent/wit/processor.wit`.

## Interface

The interface has three methods to implement

### Metadata

Name and version of your plugin

<Tabs>
  <Tab title="Go">
    <CodeGroup>

    ```go main.go
    mapper.Exports.Metadata = func() mapper.Meta {
        return mapper.Meta{
            Name:    "golang-example",
            Version: "0.1.0",
        }
    }
    ```

    </CodeGroup>
  </Tab>
  <Tab title="Python">
    <CodeGroup>

    ```python mapper.py
    def metadata(self) -> mapper.Meta:
      return mapper.Meta(name="python-example", version="0.1.0")
    ```

    </CodeGroup>
  </Tab>
</Tabs>

### Probe

Used to tell the host which logs to send to the mapper

<Tabs>
  <Tab title="Go">
    <CodeGroup>

    ```go main.go
    mapper.Exports.Probe = func() cm.List[mapper.Selector] {
      return cm.ToList([]mapper.Selector{
          {
              Any: cm.ToList([]mapper.Pred{}),
              All: cm.ToList([]mapper.Pred{
                  mapper.PredEq(
                      cm.Tuple[string, mapper.Scalar]{
                          F0: "source.name",
                          F1: log.ScalarStr("myservice"),
                      },
                  )}),
              None: cm.ToList([]mapper.Pred{}),
          },
      })
    }
    ```

    </CodeGroup>
  </Tab>
  <Tab title="Python">
    <CodeGroup>

    ```python mapper.py
    def probe(self) -> List[mapper.Selector]:
      # Match logs where source.name == "myservice"
      return [
          mapper.Selector(
              any=[],
              all=[
                  mapper.Pred_Eq(
                      ("source.name", log.Scalar_Str("myservice"))
                  )
              ],
              none=[],
          )
      ]
    ```

    </CodeGroup>
  </Tab>
</Tabs>

Will send all logs with

```json
{"source.name": "myservice"}
```

or

```json
{"source": {"name": "my service"}}
```

### ProcessLogs

This is the business logic of your plugin. It takes in a `log.Logview`, which allows it to read `json` data provided by the host. This function can return scalars, lists, or maps.

Performance note: Always prefer to fetch scalar values from the log. Scalars do not create heap allocations. Fetching lists and maps allocate on the heap, which hurts performance.

<Tabs>
  <Tab title="Go">
    <CodeGroup>

    ```go main.go
    // scaffolded project provides imports and types
    mapper.Exports.ProcessLogs = func(input cm.List[log.Logview]) (res cm.Result[cm.List[uint8], cm.List[uint8], string]) {
        buf := bufPool.Get().(*bytes.Buffer)
        buf.Reset()
        
        // take an owned copy of the input.
        var items []log.Logview
        items = append(items, input.Slice()...)
        for idx := range items {
            var out ExampleOutput
        
            lv := log.Logview(items[idx])
        
            // Get String
            msg := tangenthelpers.GetString(lv, "msg")
            if msg != nil {
                out.Msg = *msg
            }
          }
          res.SetOK(cm.ToList(buf.Bytes()))
          bufPool.Put(buf)
          return
    }
    ```

    </CodeGroup>
  </Tab>
  <Tab title="Python">
    <CodeGroup>

    ```python mapper.py
    def process_logs(self, logs: List[log.Logview]) -> bytes:
      buf = bytearray()
      for lv in logs:
          with lv:
              out = {
                  "message": "",
                  "level": "",
                  "seen": 0,
                  "duration": 0.0,
                  "service": "",
                  "tags": None,
              }
    
              # get string
              s = lv.get("msg")
              if s is not None and hasattr(s, "value"):
                  out["message"] = s.value
    
              # get dot path
              s = lv.get("msg.level")
              if s is not None and hasattr(s, "value"):
                  out["level"] = s.value
    
              # get int
              s = lv.get("seen")
              if s is not None and hasattr(s, "value"):
                  out["seen"] = s.value
    
              # get float
              s = lv.get("duration")
              if s is not None and hasattr(s, "value"):
                  out["duration"] = s.value
    
              # get value from nested json
              s = lv.get("source.name")
              if s is not None and hasattr(s, "value"):
                  out["service"] = s.value
    
              # get string list
              lst = lv.get_list("tags")
              if lst is not None:
                  tags: List[str] = []
                  for item in lst:
                      tags.append(item.value)
                  out["tags"] = tags
    
              buf.extend(json.dumps(out).encode('utf-8') + b"\n")
      return bytes(buf)
    ```

    </CodeGroup>
  </Tab>
</Tabs>

### Local dev loop

```bash
tangent plugin compile --config tangent.yaml --wit ./.tangent/wit
tangent plugin test --config tangent.yaml
tangent run --config tangent.yaml

# In a separate window
tangent bench --config tangent.yaml --seconds 30 --payload tests/input.json
```